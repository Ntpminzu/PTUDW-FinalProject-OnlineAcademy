import db from "../utils/db.js";

export default {

  findAll() {
    return db('courses as c')
      .join('sub_cat as s', 'c.SubCatID', '=', 's.SubCatID')
      .join('categories as ca', 's.CatID', '=', 'ca.CatID')
      .join('users as u', 'c.UserID', '=', 'u.UserID') // D√πng UserID
      .select('c.*', 'ca.CatName', 's.SubCatName', 'u.Fullname as InstructorName');
  },

  // L·∫•y chi ti·∫øt kh√≥a h·ªçc (bao g·ªìm t√™n GV, Cat, SubCat)
  async findByIdWithDetails(courseId) {
    return db('courses as c')
      .where('c.CourseID', courseId)
      .join('sub_cat as s', 'c.SubCatID', '=', 's.SubCatID')
      .join('categories as ca', 's.CatID', '=', 'ca.CatID')
      .join('users as u', 'c.UserID', '=', 'u.UserID') // D√πng UserID
      .select('c.*', 'ca.CatName', 's.SubCatName', 'u.Fullname as InstructorName')
      .first(); // Ch·ªâ l·∫•y 1 k·∫øt qu·∫£
  },

  // H√†m m·ªõi cho app.js l·∫•y course cho dropdown navbar
  findByCategoryLimit(catId, limit) {
    return db('courses as c')
      .join('sub_cat as s', 'c.SubCatID', '=', 's.SubCatID')
      .where('s.CatID', catId)
      .orderBy('c.Views', 'desc')
      .limit(limit)
      .select('c.CourseID', 'c.CourseName');
  },

  // D√πng UserID, SubCatID
  findBySubCategory(subCatId) { // T√¨m theo SubCategory
    return db('courses')
      .join('users', 'courses.UserID', '=', 'users.UserID') // D√πng UserID
      .where('courses.SubCatID', subCatId)
      .select('courses.*', 'users.Fullname as InstructorName');
  },

  findByUserId(userId) { // T√¨m course c·ªßa gi·∫£ng vi√™n
    return db('courses as c')
      .where('c.UserID', userId) // D√πng UserID
      .join('sub_cat as s', 'c.SubCatID', '=', 's.SubCatID')
      .join('categories as ca', 's.CatID', '=', 'ca.CatID')
      .select('c.*', 'ca.CatName', 's.SubCatName'); // L·∫•y t√™n Cat, SubCat
  },

  // TH√äM: H√†m th√™m kh√≥a h·ªçc m·ªõi
  add(courseEntity) {
    return db('courses').insert(courseEntity);
  },

  findByCategory(SubCatID) {
    return db('courses')
      .join('users', 'courses.UserID', '=', 'users.UserID')
      .join('sub_cat', 'courses.SubCatID', '=', 'sub_cat.SubCatID')
      .join('categories', 'sub_cat.CatID', '=', 'categories.CatID')
      .where('courses.SubCatID', SubCatID)
      .select(
        'courses.*',
        'users.Fullname as InstructorName',
        'categories.CatName as CategoryName',
        'sub_cat.SubCatName as SubCategoryName'
      );
  },

  findTop10CoursesViews() {
    return db('courses as c')
      .leftJoin('users as u', 'c.UserID', 'u.UserID') // UserID
      .leftJoin('sub_cat as s', 'c.SubCatID', 's.SubCatID')
      .leftJoin('categories as ca', 's.CatID', 'ca.CatID')
      .orderBy('c.Views', 'desc')
      .select('c.*', 'u.Fullname as InstructorName', 'ca.CatName', 's.SubCatName')
      .limit(10);
  },

  findTop4WeekViews() {
    return db('courses as c')
      .join('users as u', 'c.UserID', '=', 'u.UserID') // UserID
      .join('sub_cat as s', 'c.SubCatID', '=', 's.SubCatID')
      .join('categories as ca', 's.CatID', '=', 'ca.CatID')
      .select('c.*', 'u.Fullname as InstructorName', 'ca.CatName', 's.SubCatName')
      .orderBy('c.WeekView', 'desc')
      .select(
      'c.CourseID',
      'c.CourseName',
      'c.ImageUrl',
      'c.Rating',
      'c.Total_Review',
      'c.CurrentPrice',
      'c.OriginalPrice',
      'c.WeekView',
      'u.Fullname as InstructorName',
      'ca.CatName as CategoryName'
      )
      .limit(4);
  },

  // S·ª¨A: 'courses.InstructorID' -> 'courses.UserID'
  findTop10WeekViews() {
    return db('courses')
      .join('users', 'courses.UserID', '=', 'users.UserID')
      .join('categories', 'courses.SubCatID', '=', 'categories.CatID')
      .select(
        'courses.*',
        'users.Fullname as InstructorName',
        'categories.CatName as CategoryName'
      )
      .orderBy('WeekView', 'desc')
      .limit(10);
  },

  findTop10Newest() {
    return db('courses as c')
      .join('users as u', 'c.UserID', '=', 'u.UserID') // UserID
      .join('sub_cat as s', 'c.SubCatID', '=', 's.SubCatID')
      .join('categories as ca', 's.CatID', '=', 'ca.CatID')
      .select('c.*', 'u.Fullname as InstructorName', 'ca.CatName', 's.SubCatName')
      .orderBy('c.Date', 'desc') // S·∫Øp x·∫øp theo ng√†y t·∫°o
      .limit(10);
  },


  // D√πng SubCatID
  findByCategoryPaging(subCatId, limit, offset) { // ƒê·ªïi t√™n param
    return db('courses as c')
      .join('users as u', 'c.UserID', '=', 'u.UserID') // UserID
      .join('sub_cat as s', 'c.SubCatID', '=', 's.SubCatID')
      .join('categories as ca', 's.CatID', '=', 'ca.CatID')
      .where('c.SubCatID', subCatId)
      .select('c.*', 'u.Fullname as InstructorName', 'ca.CatName', 's.SubCatName')
      .limit(limit)
      .offset(offset);
  },

  
  countByCategory(SubCatID) {
    return db('courses')
      .where('SubCatID', SubCatID)
      .count('* as total')
      .first();
  },

  findByName(keyword) {
    return db('courses')
      .whereRaw('LOWER("CourseName") LIKE ?', [`%${keyword.toLowerCase()}%`])
      .first();
  },

  // S·ª¨A: 'courses.UserID'
  async findByKeyword(keyword, sortBy = 'name_asc', limit = 6, offset = 0) {
    const term = `%${keyword.toLowerCase()}%`;

    // Base query
    const baseQuery = db('courses as c')
      .join('users as u', 'c.UserID', '=', 'u.UserID')
      .join('sub_cat as s', 'c.SubCatID', '=', 's.SubCatID')
      .join('categories as ca', 's.CatID', '=', 'ca.CatID')
      .whereRaw(`
        LOWER(c."CourseName") LIKE ? OR
        LOWER(c."TinyDes") LIKE ? OR
        LOWER(c."FullDes") LIKE ? OR
        LOWER(ca."CatName") LIKE ? OR
        LOWER(s."SubCatName") LIKE ? OR
        LOWER(u."Fullname") LIKE ?
      `, [term, term, term, term, term, term])
      .select(
        'c.CourseID',
        'c.CourseName',
        'c.ImageUrl',
        'c.Rating',
        'c.TotalStudent',
        'c.CurrentPrice',
        'c.OriginalPrice',
        'u.Fullname as InstructorName',
        'ca.CatName as CategoryName'
      );

    // ‚úÖ Th√™m s·∫Øp x·∫øp
      switch (sortBy) {
        case 'name_asc': baseQuery.orderBy('c.CourseName', 'asc'); break;
        case 'name_desc': baseQuery.orderBy('c.CourseName', 'desc'); break;
        case 'price_asc': baseQuery.orderBy('c.CurrentPrice', 'asc'); break;
        case 'price_desc': baseQuery.orderBy('c.CurrentPrice', 'desc'); break;
        case 'rating_desc': baseQuery.orderBy('c.Rating', 'desc'); break;
        default: baseQuery.orderBy('c.CourseName', 'asc');
      }

    // L·∫•y d·ªØ li·ªáu c√≥ ph√¢n trang
    const results = await baseQuery.clone().limit(limit).offset(offset);

    // ƒê·∫øm t·ªïng s·ªë k·∫øt qu·∫£
    const totalResult = await db('courses as c')
      .join('users as u', 'c.UserID', '=', 'u.UserID')
      .join('sub_cat as s', 'c.SubCatID', '=', 's.SubCatID')
      .join('categories as ca', 's.CatID', '=', 'ca.CatID')
      .whereRaw(`
        LOWER(c."CourseName") LIKE ? OR
        LOWER(c."TinyDes") LIKE ? OR
        LOWER(c."FullDes") LIKE ? OR
        LOWER(ca."CatName") LIKE ? OR
        LOWER(s."SubCatName") LIKE ? OR
        LOWER(u."Fullname") LIKE ?
      `, [term, term, term, term, term, term])
      .count('* as count')
      .first();

    return { results, total: parseInt(totalResult.count) };
    },
  // finduserenrollcourses 
  async finduserenrollcourses(UserId) {
      return db('enrollments as e')
        .join('courses as c', 'e.CourseID', 'c.CourseID')
        .join('sub_cat as s', 'c.SubCatID', '=', 's.SubCatID')
        .join('categories as ca', 's.CatID', '=', 'ca.CatID')
        .select('c.*', 'ca.CatName', 's.SubCatName', 'e.enrolled_at')
        .where('e.UserID', UserId)
        .orderBy('e.enrolled_at', 'desc');
  },
  // üßÆ ƒê·∫øm t·ªïng s·ªë kh√≥a h·ªçc m√† user ƒë√£ ghi danh
    async countUserEnrollCourses(UserId) {
      const result = await db('enrollments')
        .where('UserID', UserId)
        .count('CourseID as total')
        .first();
      return parseInt(result.total, 10) || 0;
    },

// üìÑ L·∫•y danh s√°ch kh√≥a h·ªçc theo ph√¢n trang (limit + offset)
  async findUserEnrollCoursesPaging(UserId, limit, offset) {
    return db('enrollments as e')
      .join('courses as c', 'e.CourseID', 'c.CourseID')
      .join('sub_cat as s', 'c.SubCatID', '=', 's.SubCatID')
      .join('categories as ca', 's.CatID', '=', 'ca.CatID')
      .select('c.*', 'ca.CatName', 's.SubCatName', 'e.enrolled_at')
      .where('e.UserID', UserId)
      .orderBy('e.enrolled_at', 'desc')
      .limit(limit)
      .offset(offset);
  },


  //--- C√ÅC H√ÄM TH·ªêNG K√ä CHO QU·∫¢N L√ù GI·∫¢NG VI√äN ---//
  // H√†m tr·ª£ gi√∫p ƒë·ªÉ t·∫°o ƒëi·ªÅu ki·ªán WHERE
  _createWhereClause(userId = null) {
      return userId ? { UserID: userId } : {}; // L·ªçc theo UserID
    },

  // ƒê·∫øm t·ªïng s·ªë kh√≥a h·ªçc (c·ªßa GV ho·∫∑c t·∫•t c·∫£)
  async countCourses(userId = null) {
    const whereClause = this._createWhereClause(userId);
    const result = await db('courses').where(whereClause).count('CourseID as total').first();
    return result.total || 0;
  },

  // T√≠nh t·ªïng s·ªë h·ªçc vi√™n (c·ªßa GV ho·∫∑c t·∫•t c·∫£)
  async sumStudents(userId = null) {
    const whereClause = this._createWhereClause(userId);
    const result = await db('courses').where(whereClause).sum('TotalStudent as total').first();
    return result.total || 0;
  },

  // T√≠nh rating trung b√¨nh (c·ªßa GV ho·∫∑c t·∫•t c·∫£)
  async averageRating(userId = null) {
      const whereClause = this._createWhereClause(userId); // D√πng UserID theo schema m·ªõi
      const result = await db('courses')
          .where(whereClause)
          .andWhere('Rating', '>', 0) // Ch·ªâ t√≠nh c√°c kh√≥a h·ªçc c√≥ rating
          .avg('Rating as average')
          .first();

      // S·ª¨A: Ki·ªÉm tra result.average tr∆∞·ªõc khi g·ªçi toFixed
      if (result && typeof result.average === 'number') {
          return parseFloat(result.average.toFixed(1)); // L√†m tr√≤n n·∫øu l√† s·ªë
      } else if (result && typeof result.average === 'string') {
          // N·∫øu k·∫øt qu·∫£ avg tr·∫£ v·ªÅ l√† string (m·ªôt s·ªë DB c√≥ th·ªÉ l√†m v·∫≠y)
          const numAvg = parseFloat(result.average);
          return isNaN(numAvg) ? 0 : parseFloat(numAvg.toFixed(1));
      }
      // N·∫øu kh√¥ng c√≥ k·∫øt qu·∫£ ho·∫∑c kh√¥ng ph·∫£i s·ªë, tr·∫£ v·ªÅ 0
      return 0;
  },

  // ƒê·∫øm s·ªë kh√≥a h·ªçc theo t·ª´ng tr·∫°ng th√°i (c·ªßa GV ho·∫∑c t·∫•t c·∫£)
  async countCoursesByStatus(userId = null) {
    const whereClause = this._createWhereClause(userId);
    const results = await db('courses')
      .where(whereClause)
      .groupBy('CourseStatus')
      .select('CourseStatus')
      .count('CourseID as count');
    
    // Chuy·ªÉn k·∫øt qu·∫£ th√†nh d·∫°ng { complete: 5, not complete: 10, ... }
    const counts = {};
    results.forEach(row => {
      counts[row.CourseStatus || 'unknown'] = row.count;
    });
    return counts;
  },

  // H√†m c·∫≠p nh·∫≠t th√¥ng tin kh√≥a h·ªçc
  update(courseId, courseUpdates) {
    return db('courses').where('CourseID', courseId).update(courseUpdates);
  },

  // H√†m x√≥a kh√≥a h·ªçc theo CourseID
  delete(courseId) {
    return db('courses').where('CourseID', courseId).del();
  },

  //--- H·∫æT C√ÅC H√ÄM TH·ªêNG K√ä CHO QU·∫¢N L√ù GI·∫¢NG VI√äN ---//

  // C√°c h√†m kh√°c
  findById(courseId) {
    return db('courses')
      .leftJoin('users', 'courses.UserID', '=', 'users.UserID')
      .leftJoin('categories', 'courses.SubCatID', '=', 'categories.CatID')
      .where('courses.CourseID', courseId)
      .select(
        'courses.*',
        'users.Fullname as InstructorName',
        'categories.CatName as CategoryName'
      )
      .first();
  },
  checkIfInWishlist(userId, courseId) {
    return db('watch_list')
      .where('UserID', userId)
      .andWhere('CourseID', courseId);
  },
  checkIfInEnrollments(userId, courseId) {
    return db('enrollments')
      .where('UserID', userId)
      .andWhere('CourseID', courseId);
  },
  checkIfInFeedbacks(userId, courseId) {
    return db('course_feedback')
      .where('UserID', userId)
      .andWhere('CourseID', courseId);
  },
  findLessonsByCourseId(courseId) {
    return db('lessons')
      .where('CourseID', courseId)
      .select(
        'LessonID',
        'LessonName',
        'TinyDes',
        'FullDes',
        'VideoUrl',
        'LessonStatus',
        'LessonPermission',
        'LastUpdate',
        'CourseID',
        'UserID'
      )
      .orderBy('LastUpdate', 'asc');
  },
  findFeedbacksByCourseId(courseId) {
    return db('course_feedback')
      .where('CourseID', courseId)
      .leftJoin('users', 'course_feedback.UserID', '=', 'users.UserID')
      .select(
        'Fullname',
        'CourseID',
        'Feedback',
        'created_at'
      )
      .orderBy('created_at', 'asc');
  },
async findRelatedCourses(courseId, catId) {
  const sameCat = await db('courses as c')
    .join('users as u', 'c.UserID', '=', 'u.UserID')
    .join('sub_cat as s', 'c.SubCatID', '=', 's.SubCatID')
    .join('categories as ca', 's.CatID', '=', 'ca.CatID')
    .where('ca.CatID', catId)
    .andWhereNot('c.CourseID', courseId)
    .select(
      'c.CourseID',
      'c.CourseName',
      'c.ImageUrl',
      'c.Rating',
      'c.Total_Review',
      'c.TotalStudent',  
      'c.CurrentPrice',
      'c.OriginalPrice',
      'u.Fullname as InstructorName',
      'ca.CatName as CategoryName'
    )
    .orderBy('c.Views', 'desc')
    .limit(5);

  if (sameCat.length >= 5) return sameCat;

  const remaining = 5 - sameCat.length;

  const extra = await db('courses as c')
    .join('users as u', 'c.UserID', '=', 'u.UserID')
    .join('sub_cat as s', 'c.SubCatID', '=', 's.SubCatID')
    .join('categories as ca', 's.CatID', '=', 'ca.CatID')
    .whereNot('c.CourseID', courseId)
    .select(
      'c.CourseID',
      'c.CourseName',
      'c.ImageUrl',
      'c.Rating',
      'c.Total_Review',
      'c.TotalStudent',   
      'c.CurrentPrice',
      'c.OriginalPrice',
      'u.Fullname as InstructorName',
      'ca.CatName as CategoryName'
    )
    .orderByRaw('RANDOM()')
    .limit(remaining);

  return [...sameCat, ...extra];
}



};